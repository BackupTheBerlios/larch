#!/usr/bin/env python
#
# guibuild.py
#
# (c) Copyright 2009 Michael Towers (larch42 at googlemail dot com)
#
# This file is part of the larch project.
#
#    larch is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    larch is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with larch; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#----------------------------------------------------------------------------
# 2009.06.22

"""Build a gui from a layout description.
"""

import sys, traceback
from PyQt4 import QtGui, QtCore
import re

#++++++++++++++++++++++++++++++++++++++++++++++++++++
#TODO
# Add more widgets
# Add more attribute handling
# Add more signal handling

#----------------------------------------------------


def _TEXT(item):
    """A function to add formatting markup to a string, if the item is a
    list. If it is a string it is returned as is.

    The markup must be supplied in the dictionary '_stringformats'.
    At present this function fails 'gracefully', using no formatting
    if the given format is not defined and a dummy text if not enough
    texts are supplied.
    """
    def subf(mo):
        i = int(mo.group(1))
        if i > len(subs):
            return "***Not Defined***"
        else:
            return subs[i - 1]

    if isinstance(item, str) or isinstance(item, unicode):
        return item

    # Need to do %-substitution
    format = item[0]
    rex = re.compile(r"%(\d)")
    subs = []
    for a in item[1:]:
        if isinstance(a, tuple):
            f = _stringformats.get(a[1])
            if f:
                text = f % a[0]
            else:
                text = a[0]
        else:
            text = a
        subs.append(text)
    return rex.sub(subf, format)


# Widget classes
class TopLevel:
    """This class cannot be used directly (it must be subclassed) because
    it doesn't set 'self.widget' itself, this must be set before
    calling this '__init__'.
    """
    def __init__(self, title, header):
        self.layout = QtGui.QVBoxLayout()                   #qt
        self.widget.setLayout(self.layout)                  #qt
        self.widget.setWindowTitle(title)                   #qt
        if header:                                          #qt
            self.header = QtGui.QLabel(_TEXT(header))       #qt
            self.layout.addWidget(self.header)              #qt
        else:
            self.header = None

    def set_widget(self, widget):
        """Set the main widget within the top level window.
        """
        self.layout.addWidget(widget)                       #qt


class Window(TopLevel):
    def __init__(self, title, header):
        self.widget = QtGui.QWidget()                       #qt
        TopLevel.__init__(self, title, header)


class Dialog(TopLevel):
    def __init__(self, title, header):
        self.widget = QtGui.QDialog()                       #qt
        TopLevel.__init__(self, title, header)


class Notebook(QtGui.QTabWidget):                           #qt
    s_default = "changed"
    s_signals = {
            "changed": "currentChanged(int)"                #qt
        }
    def __init__(self, args):
        QtGui.QTabWidget.__init__(self)                     #qt
        self.x_tabs = []
        self.x_mywidgets = {}

        for tab in args:
            tname = tab[0]
            tw = _NotebookPage()                            #qt
            self.addTab(tw, _TEXT(tab[1]))                  #qt
            tw.name = tname                                 #qt
            self.x_mywidgets[tname] = tw                    #qt

            self.x_tabs.append([tname, tw])

class _NotebookPage(QtGui.QWidget):                         #qt
    def __init__(self):                                     #qt
        QtGui.QWidget.__init__(self)                        #qt


class Frame(QtGui.QGroupBox):                               #qt
    def __init__(self, text=""):
        QtGui.QGroupBox.__init__(self, _TEXT(text))         #qt


class OptionalFrame(Frame):                                 #qt
    def __init__(self, text=""):                            #qt
        Frame.__init__(self, text)                          #qt
        self.setCheckable(True)                             #qt
        self.setChecked(False)                              #qt


class Label(QtGui.QLabel):                                  #qt
    def __init__(self, text=""):
        QtGui.QLabel.__init__(self, _TEXT(text))            #qt

    def x_set_align(self, pos):
        if pos == "center":
            a = QtCore.Qt.AlignCenter                       #qt
        else:
            a = QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter       #qt
        self.setAlignment(a)                                #qt


class Button(QtGui.QPushButton):                            #qt
    s_default = "clicked"
    s_signals = {
            "clicked": "clicked()"                          #qt
        }
    def __init__(self, text=""):
        QtGui.QPushButton.__init__(self, _TEXT(text))       #qt


class ComboBox(QtGui.QComboBox):                            #qt
    s_default = "changed"
    s_signals = {
            "changed": "currentIndexChanged(int)" ,         #qt
            "changedstr": "currentIndexChanged(const QString &)"    #qt
        }
    def __init__(self):
        QtGui.QComboBox.__init__(self)                      #qt

    def set(self, items, index=0):
        self.blockSignals(True)
        self.clear()
        if items:
            self.addItems(items)
            self.setCurrentIndex(index)
        self.blockSignals(False)


class LineEdit(QtGui.QLineEdit):                            #qt
    s_default = "changed"
    s_signals = {
            "enter": "returnPressed()",                     #qt
            "changed": "textEdited(const QString &)"        #qt
        }
    def __init__(self, text=""):
        QtGui.QLineEdit.__init__(self, _TEXT(text))         #qt


class CheckList(QtGui.QWidget):                             #qt
    def __init__(self, text=""):                            #qt
        QtGui.QWidget.__init__(self)                        #qt
        l = QtGui.QVBoxLayout(self)                         #qt
        if text:                                            #qt
            l.addWidget(QtGui.QLabel(_TEXT(text)))          #qt
        self.widget = QtGui.QListWidget()                   #qt
        l.addWidget(self.widget)                            #qt

    def checked(self, index):
        return (self.widget.item(index).checkState() ==     #qt
                QtCore.Qt.Checked)                          #qt

    def set(self, items):
        self.widget.blockSignals(True)                      #qt
        self.widget.clear()                                 #qt
        if items:
            for s, c in items:
                wi = QtGui.QListWidgetItem(s, self.widget)  #qt
                wi.setCheckState(QtCore.Qt.Checked if c     #qt
                        else QtCore.Qt.Unchecked)           #qt
        self.blockSignals(False)                            #qt


# Layout classes
class _BOX:
    def __init__(self, items):
        self.x_children = items

    def add_children(self, widgets):
        for c in self.x_children:
            wl = widgets[c]
            if isinstance(wl, QtGui.QWidget):               #qt
                self.addWidget(wl)                          #qt
            elif isinstance(wl, SPACE):                     #qt
                self.addStretch()                           #qt
            else:                                           #qt
                self.addLayout(wl)                          #qt


class VBOX(QtGui.QVBoxLayout, _BOX):                        #qt
    def __init__(self, items):
        QtGui.QVBoxLayout.__init__(self)                    #qt
        _BOX.__init__(self, items)                          #qt


class HBOX(QtGui.QHBoxLayout, _BOX):                        #qt
    def __init__(self, items):
        QtGui.QHBoxLayout.__init__(self)                    #qt
        _BOX.__init__(self, items)                          #qt


class GRID(QtGui.QGridLayout):                              #qt
    def __init__(self, *rows):
        QtGui.QGridLayout.__init__(self)                    #qt
        self.x_children = rows

    def add_children(self, widgets):
        y = -1
        for row in self.x_children:
            y += 1
            x = -1
            for col in row:
                x += 1
                wl = widgets.get(col)
                if not wl:
                    continue
                # Determine the row and column spans
                x1 = x + 1
                while (x1 < len(row)) and (row[x1] == "-"):
                    x1 += 1
                y1 = y + 1
                while ((y1 < len(self.x_children)) and
                        (self.x_children[y1][x] == "|")):
                    y1 += 1

                if isinstance(wl, QtGui.QWidget):           #qt
                    self.addWidget(wl, y, x, y1-y, x1-x)    #qt
                else:                                       #qt
                    self.addLayout(wl, y, x, y1-y, x1-x)    #qt


class SPACE:                                                #qt
    def __init__(self):                                     #qt
        pass                                                #qt


class HLINE(QtGui.QFrame):                                  #qt
    def __init__(self):
        QtGui.QFrame.__init__(self)                         #qt
        self.setFrameShape(QtGui.QFrame.HLine)              #qt


class VLINE(QtGui.QFrame):                                  #qt
    def __init__(self):
        QtGui.QFrame.__init__(self)                         #qt
        self.setFrameShape(QtGui.QFrame.VLine)              #qt


class Signal:
    """Each instance represents a single connection.
    """
    def __init__(self, widgettree):
        self.widgettree = widgettree

    def connect(self, source, signal, name=None, tag=None):
        """'source' is the widget which initiates the signal.
        'signal' is the name of the signal.
        If 'name' is given, the signal will get this as its name,
        and this name may be used for more than one connection.
        Otherwise the name is built as 'source_signal' and may
        only be used once.
        'tag' is passed as the first argument to the signal handler.
        Normal arguments of the signal follow.
        """
        w = self.widgettree.widgets.get(source)
        if not w:
            gui_warning(_("Unknown widget: %s") % source)
            return None
        sig = w.s_signals.get(signal)
        if not sig:
            gui_warning(_("Signal '%s' is not defined for '%s'.")
                        % (signal, source.x_name))
            return None
        if name:
            l = self.widgettree.connections.get(name, [])
        else:
            l = self
            name = "%s_%s" % (source, signal)
            if self.widgettree.connections.has_key(name):
                gui_warning(_("Signal '%s' is defined more than once.")
                        % name)
                return None
        self.name = name
        self.tag = tag
        try:
            handler = getattr(self, w.s_handler)
        except:
            handler = self.signal
        if QtCore.QObject.connect(w, QtCore.SIGNAL(sig), handler):  #qt
            self.name = name
            if l != self:
                l.append(self)
            return l
        else:
            gui_warning(_("Signal '%s' couldn't be connected.")
                    % name)
            return None

    def signal(self, *args):
        print "SIGNAL", self.name, self.tag, args

#    def disconnect(self):
#        ???


class WidgetTree:
    """This class represents a gui window as defined in a layout file.
    """
    def __init__(self, info):
        global _stringformats
        _stringformats = info.get("StringFormats", {})
        self.connections = {}

        # Create all widgets
        wlist = info["Widgets"]
        main = wlist[0][1]

        self.widgets = {}
        for w in wlist:
            wtype = w[0]
            wname = w[1]
            if wname[0] == "^":
                wname = wname[1:]
                connect = True
            else:
                connect = False
            if wtype[0] == "*":
                wo = widget_table[wtype[1:]](*w[2:])
                setattr(self, wname, wo)
            else:
                wo = widget_table[wtype](*w[2:])
            self.widgets[wname] = wo
            wo.x_name = wname
            if connect:
                s = Signal(self)
                c = s.connect(wname, wo.s_default)
                if c:
                    self.connections[s.name] = c


            # The widget may itself have created widgets that need including
            try:
                self.widgets.update(wo.x_mywidgets)
            except:
                pass

        self.mainwidget = self.widgets[main]


        # Do the layouts in two stages to allow definition-after-use
        layout = info["Layout"]
        pending = []
        for l in layout:
            ltype = l[0]
            if ltype[0] == "+":
                pending.append(l)

            else:
                lname = l[1]
                lo = layout_table[ltype](*l[2:])
                lo.x_name = lname
                if hasattr(lo, "x_children"):
                    pending.append(("+", lo))
                self.widgets[lname] = lo

        for p in pending:
            ptype = p[0]
            if ptype == "+":
                p[1].add_children(self.widgets)

            elif ptype == "+MAIN":
                self.mainwidget.set_widget(self.widgets[p[1]])

            elif ptype == "+LAYOUT":
                self.widgets[p[1]].setLayout(self.widgets[p[2]])

            else:
                gui_error(_("Unknown node type: %s") % ptype)
                # fatal


        # Handle attributes
        attributes = info.get("Attributes", [])
        # This is a list of [widget, attribute, value] triplets
        for w, a, v in attributes:
            widget = self.widgets.get(w)
            if not widget:
                gui_warning(_("Unknown widget: %s") % w)
                continue
            setter = "x_set_" + a
            try:
                getattr(widget, setter)(v)
            except:
                # If there is no setter, just ignore it
                pass


        # Connect signals
        signals = info.get("Signals", [])
        # This is a list of [widget, signal, arg] triplets, but the
        # 'arg' element may be missing.
        for conn in signals:
            s = Signal(self)
            c = s.connect(*conn)
            if c:
                self.connections[s.name] = c


    def show(self):
        self.mainwidget.widget.show()


#+++++++++++++++++++++++++++
# Error handling
def gui_error(message, title=None):
    if not title:
        title = _("larch gui error")
    d = QtGui.QMessageBox.critical(None, title, message)    #qt
    sys.exit(1)

def gui_warning(message, title=None):
    if not title:
        title = _("larch gui warning")
    d = QtGui.QMessageBox.warning(None, title, message)     #qt
#---------------------------

#+++++++++++++++++++++++++++
# Catch all unhandled errors.
def errorTrap(type, value, tb):
    etext = "".join(traceback.format_exception(type, value, tb))
    gui_error(etext, _("This error could not be handled."))

sys.excepthook = errorTrap
#---------------------------

widget_table = {
    "Window": Window,
    "Dialog": Dialog,
    "Notebook": Notebook,
    "Frame": Frame,
    "Button": Button,
    "Label": Label,
    "CheckList": CheckList,
    "OptionalFrame": OptionalFrame,
    "ComboBox": ComboBox,
    "LineEdit": LineEdit
}

layout_table = {
    "VBOX": VBOX,
    "HBOX": HBOX,
    "GRID": GRID,
    "VSPACE": SPACE,
    "HSPACE": SPACE,
    "VLINE": VLINE,
    "HLINE": HLINE
}


if __name__ == "__main__":
    app = QtGui.QApplication([])                            #qt
    def _(text): return text

    d = {}
    execfile("gui.layout.py", globals(), d)
    window = WidgetTree(d)


    window.widgets["choose_profile_combo"].set(["one", "two"])
    window.widgets["host_db"].set([("First", True), ("Second", False)])

    window.show()                                           #qt
    app.exec_()                                             #qt

