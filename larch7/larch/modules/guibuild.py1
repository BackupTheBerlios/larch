#!/usr/bin/env python
#
# guibuild.py
#
# (c) Copyright 2009 Michael Towers (larch42 at googlemail dot com)
#
# This file is part of the larch project.
#
#    larch is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    larch is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with larch; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#----------------------------------------------------------------------------
# 2009.06.20

"""Build a gui from a layout description.
"""

from PyQt4 import QtGui, QtCore
import re

#++++++++++++++++++++++++++++++++++++++++++++++++++++
#TODO


#----------------------------------------------------

def _TEXT(item):
    """A function to add formatting markup to a string, if the item is a
    list. If it is a string it is returned as is.

    The markup must be supplied in the dictionary 'stringformats'.
    At present this function fails 'gracefully', using no formatting
    if the given format is not defined and a dummy text if not enough
    texts are supplied.
    """
    def subf(mo):
        i = int(mo.group(1))
        if i > len(subs):
            return "***Not Defined***"
        else:
            return subs[i - 1]

    if isinstance(item, str) or isinstance(item, unicode):
        return item

    # Need to do %-substitution
    format = item[0]
    rex = re.compile(r"%(\d)")
    subs = []
    for a in item[1:]:
        if isinstance(a, tuple):
            f = stringformats.get(a[1])
            if f:
                text = f % a[0]
            else:
                text = a[0]
        else:
            text = a
        subs.append(text)
    return rex.sub(subf, format)


# Widget classes
class TopLevel:
    """This class cannot be used directly (it must be subclassed) because
    it doesn't set 'self.widget' itself, this must be set before
    calling this '__init__'.
    """
    def __init__(self, title, header):
        self.layout = QtGui.QVBoxLayout()               #qt
        self.widget.setLayout(self.layout)              #qt
        self.widget.setWindowTitle(title)               #qt
        if header:                                      #qt
            self.header = QtGui.QLabel(_TEXT(header))   #qt
            self.layout.addWidget(self.header)          #qt
        else:
            self.header = None

    def set_widget(self, widget):
        """Set the main widget within the top level window.
        """
        self.layout.addWidget(widget.widget)


class Window(TopLevel):
    def __init__(self, title, header):
        self.widget = QtGui.QWidget()                   #qt
        TopLevel.__init__(self, title, header)


class Dialog(TopLevel):
    def __init__(self, title, header):
        self.widget = QtGui.QDialog()                   #qt
        TopLevel.__init__(self, title, header)


class Notebook:
    def __init__(self, args):
        self.widget = QtGui.QTabWidget()                #qt
        self.tabs = []
        self.mywidgets = {}

        for tab in args:
            tname = tab[0]
            tw = _NotebookWidget()                      #qt
            self.widget.addTab(tw.widget, _TEXT(tab[1]))    #qt
            tw.name = tname                             #qt
            self.mywidgets[tname] = tw                  #qt

            self.tabs.append([tname, tw])

class _NotebookWidget:                                  #qt
    def __init__(self):                                 #qt
        self.widget = QtGui.QWidget()                   #qt

    def set_layout(self, child):
        self.widget.setLayout(child.layout)             #qt

class Frame:
    def __init__(self, text=""):
        self.text = _TEXT(text)
        self.widget = QtGui.QGroupBox(text)             #qt

    def set_layout(self, child):
        self.widget.setLayout(child.layout)             #qt

class OptionalFrame(Frame):                             #qt
    def __init__(self, text=""):                        #qt
        Frame.__init__(self, text)                      #qt
        self.widget.setCheckable(True)                  #qt
#TODO: set up enabled

class Label:
    def __init__(self, text=""):
        self.text = _TEXT(text)
        self.widget = QtGui.QLabel(self.text)           #qt

    def align(self, pos):
        if pos == "center":
            a = QtCore.Qt.AlignCenter                   #qt
        else:
            a = QtCore.Qt.AlignRight                    #qt
        self.widget.setAlignment(a)                     #qt


class Button:
    def __init__(self, text=""):
        self.text = _TEXT(text)
        self.widget = QtGui.QPushButton(text)           #qt

class ComboBox:
    def __init__(self):
        pass

class LineEdit:
    def __init__(self, text=""):
        self.text = _TEXT(text)

class CheckList:
    def __init__(self, text=""):
        self.text = _TEXT(text)


# Layout classes
class VBOX:
    def __init__(self, items):
        self.layout = QtGui.QVBoxLayout()               #qt

    def set_layout(self, children):
        print "VBOX", self.name
        for c in children:
            print c,
        print

class HBOX:
    def __init__(self, items):
        self.layout = QtGui.QHBoxLayout()               #qt

    def set_layout(self, children):
        print "HBOX", self.name
        for c in children:
            print c,
        print


class GRID:
    def __init__(self, *rows):
        self.layout = QtGui.QGridLayout()               #qt

    def set_layout(self, children):
        print "GRID", self.name
        for c in children:
            print c,
        print
        pass

class HSPACE:
    def __init__(self):
        pass

class VSPACE:
    def __init__(self):
        pass

class HLINE:
    def __init__(self):
        pass

class VLINE:
    def __init__(self):
        pass



class WidgetTree:
    """This class represents a gui window as defined in a layout file.
    """
    def __init__(self, info):
        global stringformats
        stringformats = info.get("StringFormats", {})
        wlist = info["Widgets"]
        main = wlist[0][1]

        self.widgets = {}
        for w in wlist:
            wtype = w[0]
            wname = w[1]
            if wtype[0] == "*":
                wo = widget_table[wtype[1:]](*w[2:])
                self.__dict__[wname] = wo
            else:
                wo = widget_table[wtype](*w[2:])
            self.widgets[wname] = wo
            wo.name = wname

            # The widget may itself have created widgets that need including
            wox = wo.__dict__.get("mywidgets")
            if wox:
                self.widgets.update(wox)

        self.mainwidget = self.widgets[main]

        # Do the layouts in two stages to allow definition-after-use
        layout = info["Layout"]
        pending = []
        for l in layout:
            ltype = l[0]
            if ltype[0] == "+":
                pending.append(l)

            else:
                lname = l[1]
                lo = layout_table[ltype](*l[2:])
                lo.name = lname
                if lo.__dict__.has_key("set_layout"):
                    pending.append("+", lo)
                self.widgets[lname] = lo

        for p in pending:
            ptype = p[0]
            if ptype == "+":
                p[1].do_pending()

            elif ptype == "+MAIN":
                self.mainwidget.set_widget(self.widgets[p[1]])

            elif ptype == "+LAYOUT":
                self.widgets[p[1]].set_layout(self.widgets[p[2]])

            else:
                gui_error(_("Unknown node type: %s") % ptype)

    def show(self):
        self.mainwidget.widget.show()



widget_table = {
    "Window": Window,
    "Dialog": Dialog,
    "Notebook": Notebook,
    "Frame": Frame,
    "Button": Button,
    "Label": Label,
    "CheckList": CheckList,
    "OptionalFrame": OptionalFrame,
    "ComboBox": ComboBox,
    "LineEdit": LineEdit
}

layout_table = {
    "VBOX": VBOX,
    "HBOX": HBOX,
    "GRID": GRID,
    "VSPACE": VSPACE,
    "HSPACE": HSPACE,
    "VLINE": VLINE,
    "HLINE": HLINE
}


if __name__ == "__main__":
    app = QtGui.QApplication([])                        #qt
    def _(text): return text

    d = {}
    execfile("gui.layout.py", globals(), d)
    window = WidgetTree(d)
    window.show()                                       #qt
    app.exec_()                                         #qt

