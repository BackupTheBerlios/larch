# fstab.py - Generate /etc/fstab for the installed system
#
# (c) Copyright 2009 Michael Towers (larch42 at googlemail dot com)
#
# This file is part of the larch project.
#
#    larch is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    larch is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with larch; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#----------------------------------------------------------------------------
# 2009.10.18


# /etc/fstab needs to be set up. So we can offer some tweaks to the
# mount options (though the default should be acceptable).
# I would suggest also offering fs-type tweaks, such as data=ordered for
# ext3, and dir-indexing for ext3 (&4?). Maybe these should be the defaults?
# Though it sounds like dir-index may not be that advantageous.
# Root user %age reseration could be tweaked, also check intervals.
# uuid and/or labels can be set here.
# I guess noatime should be the default mount option.
# Generate fstab entries for all detected (fixed) partitions?
# I would need to look up something for ntfs/dos, and maybe check on
# ntfs3g?



backend:
    def usableparts(self):
        return self.xlist("get-usableparts")[1]
    def getUUID(self, part):
        return self.xcall("get-blkinfo UUID %s" % part).strip()
    def getLABEL(self, part):
        return self.xcall("get-blkinfo LABEL %s" % part).strip()



    def fstab(self, partlist, devname=False):
        """Build a suitable /etc/fstab for the newly installed system.
        partlist (entries: [mount-point, device, format-type]) contains
        the partitions which are of main interest to this method.
        """
        # Make a dict of all 'mountable' partitions
        uparts = {}
        for up in backend.usableparts():
            dev, rem, fst = up.split()
            uparts["/dev/" + dev] = (fst, rem)

        # Check that all fs-types correspond to the desired ones and
        # build lists of automount, noautomount and swap partitions.
        automounts = []
        noautomounts = []
        swaps = []
        for mp, dev, fmt in partlist:
            if mp == "swap":
                swaps.append(dev)
            else:
                fst = uparts[dev][0]
                if fmt and (fmt != fst):
                    run_error(_("Detected fstype not same as format spec: %s")
                            % dev)
                    return False
                automounts.append((mp, dev, fst))
            uparts[dev] = None
        # Now the partitions not specified in partlist
        for dev, tup in uparts.items():
            if tup and (tup[1] == "-"):
                # Only make entries for non-removable devices
                noautomounts.append((dev, tup[0])

# What about not making entries if ntfs-3g is installed? (see HAL setup)
#TODO
        ntfs3g = True


        fstab = ("# fstab generated by larchin\n"
                "#<file system>   <dir>       <type>      <options>"
                        "    <dump> <pass>\n\n")
        automounts.sort()
        for mp, dev, fst in automounts:
            pas = '1'if (mp == '/') else '2'
            # Unless device names are explicitly selected, partition
            # labels will be used, if present, or else UUID.


# As this will probably be duplicated for the noautomounts, maybe it
# should be in a separate function
            if devname:
                dn = dev
            else:
                l = backend.getLABEL(dev)
                dn = ("/dev/disk/by-label/" + l if l else
                        "/dev/disk/by-uuid/" + backend.getUUID(dev))

# As this will probably be duplicated for the noautomounts, maybe it
# should be in a separate function
            opt = "defaults"
            if fst == "ntfs":
                if ntfs3g:
                    dn = "#" + dn
#see wiki

            elif fst == "vfat":
#see wiki

            else:
                opt += ",noatime"

            fstab += ("%-15s %-12s %-8s %s 0     %s\n"
                    % (dn, mp, fst, opt, pas))


        fstab += ("\nnone            /dev/pts    devpts      defaults"
                        "        0     0\n"
                "none            /dev/shm    tmpfs       defaults"
                        "        0     0\n\n")

        fstab += "# Swaps\n"
        for p in swaps:
#TODO
            dn = ???(p)
            fstab += dn + " swap       swap   defaults        0     0\n"

        noautomounts.sort()
        for dev, fst in noautomounts:

#somewhat similar to automounts, but must make mp, and:
            s = ("#/dev/%-7s /mnt/%-7s %s    user,noauto,noatime"
                    " 0     0\n" % (devi[0], devi[0], fstype))

#???
        fstab += "\n#Optical drives\n"
        for p in self.xcall("get-cd").splitlines():
            fstab += ("#/dev/%-6s /mnt/cd_%-4s auto"
                    "   user,noauto,exec,unhide 0     0\n" % (p, p))

        # Add other partitions to /mnt if not already catered for.
        # One shouldn't assume the existing device info is up to date.


#?????????????????
# Does blkid pick up on LVM partitions? (If so, what do they look like?)
        dl = []
        for dev in self.xcall("get-lvm").splitlines():
            devm = "/dev/mapper/" + dev
            if (devm not in mainmounts):
                dl.append(dev)
        if dl:
            fstab += "\n#LVM partitions\n"
            for p in dl:
                fstab += ("#/dev/mapper/%-6s /mnt/lvm_%-4s auto"
                    "   user,noauto,noatime 0     0\n" % (p, p))

        fstab += ("\n# You may also want to add lines for removable devices,\n"
                "# though it is recommended to let HAL deal with these.\n"
                "# You will also need to create the mount point in /mnt.\n"
                "# For example:\n"
                "#/dev/sdb1 /mnt/usb    auto    user,noauto,noatime 0    0\n")

        fw = open("/tmp/larchin/fstab", "w")
        fw.write(fstab)
        fw.close()
        self.xsendfile("/tmp/larchin/fstab", "/tmp/install/etc/fstab")



