# fstab.py
#
# (c) Copyright 2010 Michael Towers (larch42 at googlemail dot com)
#
# This file is part of the larch project.
#
#    larch is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    larch is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with larch; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#----------------------------------------------------------------------------
# 2010.03.05

import backend

def generate(partlist0):
    """Build a suitable /etc/fstab for the newly installed system.
    partlist0 is a backend.Partlist instance, from which the partitions
    which are of main interest to this function can be fetched with the
    get_all method. Each entry in this list is of the form:
       [mount-point, device, format-type, (uuid/label info)]
    """
    global partlist     # Make it available for fstabentry() too
    partlist = partlist0
    # Get a dict of all 'mountable' partitions
    uparts = backend.Devices().get_mountable()
    # Each entry has the form:
    #    device: (fstype, label, uuid, removable)
    # Check that all fs-types correspond to the desired ones and
    # build lists of automount, noautomount and swap partitions.
    automounts = []
    noautomounts = []
    swaps = []
    for mdf in partlist.get_all():
        mp, dev, fmt = mdf[:3]
        if mdf[3] == '-':
            label, uuid = None, None
        else:
            partinfo = uparts.get(dev)
            if not partinfo:
                errout(_("Unusable partition: %s") % dev)
                return False
            label, uuid = partinfo[1:3]

        fst = partinfo[0]
        if mp == "swap":
            if fst != "swap":
                errout(_("Invalid swap partition: %s") % dev)
                return False
            swaps.append(("swap", dev, "swap", label, uuid))
        else:
            if fst == "swap":
                errout(_("%s seems to be a swap partition") % dev)
                return False
            if fmt and (fmt != fst):
                errout(_("Detected fstype not same as format spec: %s")
                        % dev)
                return False
            automounts.append((mp, dev, fst, label, uuid))
        del(uparts[dev])
    # Now the partitions not specified in partlist
    for dev, tup in uparts.items():
        if not tup[3]:
            # Only make entries for non-removable devices
            noautomounts.append((None, dev) + tup[0:3])

    fstab = ("# fstab generated by larchin\n"
            "#<file system>   <dir>       <type>      <options>"
                    "    <dump> <pass>\n\n")
    # Unless device names are explicitly selected partition labels will
    # be used, if present, otherwise UUIDs.
    for part in automounts:
        pas = '1'if (part[0] == '/') else '2'
        fstab += fstabentry(part, pas)

    fstab += ("\nnone            /dev/pts    devpts      defaults"
                    "        0     0\n"
            "none            /dev/shm    tmpfs       defaults"
                    "        0     0\n\n")

    fstab += "# Swaps\n"
    for part in swaps:
        fstab += fstabentry(part, 0)

    fstab += "\n# Other partitions\n"
    for part in noautomounts:
        fstab += fstabentry(part, 0)
    return fstab


def fstabentry(part, pas):
    mp = part[0]
    fst = part[2]
    dn = part[1]
    tag = dn.rsplit("/", 1)[1]
    l = part[3]
    if l:
        tag = l
        dn = "LABEL=" + l
        label = dn
    else:
        u = part[4]
        if u:
            dn = "UUID=" + u
            label = dn
        else:
            label = '-'
    # So that the information is also available for the bootloader:
    partlist.set_label(mp, label)

    opt = "defaults"
    if not mp:
        opt = "users,noauto"
        mp = "/mnt/" + tag
        mounting.mkdir(mp)

    if fst == "ntfs":
        dn = "#" + dn
        fst = "ntfs-3g"
        opt += ",umask=111,dmask=000"

    elif fst == "vfat":
        dn = "#" + dn
        opt += ",umask=111,dmask=000"

    elif fst != "swap":
        opt += ",noatime"

    return ("%-15s %-12s %-8s %s  0  %s\n"
            % (dn, mp, fst, opt, pas))
